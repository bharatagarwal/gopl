
<html>
<head>
<style><!-- @import "http://www.cs.fsu.edu/~lacher/styles/RCLstyle1.css"; --></style>
<title>Bitvectors Narrative</title>
</head>
<body>
<a NAME="Link1"></a><h1>Bits and Bytes</h1>
<p>
The <em>byte</em> is generally the smallest item of storage that is
directly accessible in modern computers, and symbiotically the byte is the
smallest item of storage used by modern programming languages. We
could think of the byte as the atomic level of data. 
</p><p>
But there is a subatomic story. A byte consists of eight bits, where a <em>bit</em> is
the electronic equivalent of a bivalent entity. In other words, a bit is capable of being
in exactly two states. We can think of these two states as true/false, +1/-1, or 1/0. The
machine has electronic representations of bits, in groups of eight, and makes these
groups of eight bits directly accessible as bytes. A byte, being the atomic data
type, is the space used to store <tt>char</tt> data. You learn a lot more about
this in our course CDA 3100 <em>Computer Organization I</em>.
</p>
<p>
One of the many legacies of C, inherited by C++, is an ability to access subatomic
data, data at the bit level, indirectly through <em>bit
operators</em>. Moreover, all modern general-purpose computers have hardware
support for these bit operators, which makes them extremely fast.  Many C
programmers use bit operators to implement various bit-level access
utilities, the most popular being the <em>bitvector</em>. The C++ class allows
us to descend to the bit level carefully and then encapsulate this
sub-atomic programming behind a public interface. We will illustrate this
entire process later in the chapter by constructing a bitvector class, a class that stores and
retrieves vectors of bivalent values at the bit level.
</p>
<p>
The byte can store any eight-digit unsigned binary number (the binary digits are usually
called bits). The range of such numbers begins with 0<sub>(10)</sub> =
00000000<sub>(2)</sub>
and ends with 11111111<sub>(2)</sub> = 255<sub>(10)</sub>. Here is the range
of numbers representable in one byte, expressed in various notations:

</p><blockquote><table border=0>
<tr><td><em>Name</em></td><td align="right"><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>Base</em></td><td><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>1-Byte Range</em></td></td>
<tr><td>Binary</td>      <td align="right">2</td> <td><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt><tt>00000000 &hellip; 11111111</tt></td></tr>
<tr><td>Octal</td>       <td align="right">8</td> <td><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt><tt>000 &hellip; 377</tt></td></tr>
<tr><td>Decimal</td>     <td align="right">10</td><td><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt><tt>0 &hellip; 255</tt></td></tr>
<tr><td>Hexadecimal</td> <td align="right">16</td><td><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt><tt>00 &hellip; FF</tt></td></tr>
</table></blockquote><p>

The hexadecimal, or hex, representation is perhaps the most convenient to use
for byte values, since it consists of exactly two hex digits. The hex digits are
<tt>&nbsp; 0 1 2 3 4 5 6 7 8 9 A B C D E F &nbsp;</tt> and the range of
two-digit hex numbers corresponds to the decimal range 0 &hellip; 255 =
16<sup>2</sup> - 1.
</p>

<p>
For further reading, see <em>Number Systems</em>, Appendix C of Dietel.

<br>
</p><a NAME="Link2"></a><h1>Bit Operators in C/C++</h1>
<p>

<p>
The following table summarizes the bit operators C++ inherits from C:

</p><blockquote>
<Table border=4 cellspacing=0>
<TR>
<TD>&nbsp;<em>operation</em><tt>&nbsp;&nbsp;&nbsp;</tt></TD>
<TD>&nbsp;<em>symbol</em>&nbsp;</TD>
<TD>&nbsp;<em>type</em></TD>
<TD>&nbsp;<em>infix version</em></TD>
<TD>&nbsp;<em>accumulator version</em> <tt>&nbsp;&nbsp;&nbsp;</tt></TD>
</TR>
<TR>
<TD>&nbsp; and</TD>
<TD>&nbsp; <tt>&amp;</tt> </TD>
<TD>&nbsp;binary</TD>
<TD>&nbsp;<tt>z = x &amp; y</tt></TD>
<TD>&nbsp;<tt>z &amp;= y</tt></TD>
</TR>
<TR>
<TD>&nbsp; or</TD>
<TD>&nbsp; <tt>|</tt> </TD>
<TD>&nbsp;binary</TD>
<TD>&nbsp;<tt>z = x | y</tt></TD>
<TD>&nbsp;<tt>z |= y</tt></TD>
</TR>
<TR>
<TD>&nbsp; xor</TD>
<TD>&nbsp; <tt>^</tt> </TD>
<TD>&nbsp;binary</TD>
<TD>&nbsp;<tt>z = x ^ y</tt></TD>
<TD>&nbsp;<tt>z ^= y</tt></TD>
</TR>
<TR>
<TD>&nbsp; not</TD>
<TD>&nbsp; <tt>~</tt> </TD>
<TD>&nbsp;unary</TD>
<TD>&nbsp;<tt>z = ~y</tt></TD>
<TD>&nbsp;(na)</TD>
</TR>
<TR>
<TD>&nbsp; left shift</TD>
<TD>&nbsp; <tt>&lt;&lt;</tt> </TD>
<TD>&nbsp;binary</TD>
<TD>&nbsp;<tt>z = y &lt;&lt; n</tt></TD>
<TD>&nbsp;(na)</TD>
</TR>
<TR>
<TD>&nbsp; right shift <tt>&nbsp;&nbsp;&nbsp;</tt></TD>
<TD>&nbsp; <tt>&gt;&gt;</tt> </TD>
<TD>&nbsp;binary <tt>&nbsp;&nbsp;&nbsp;</tt></TD>
<TD>&nbsp;<tt>z = y &gt;&gt; n</tt> <tt>&nbsp;&nbsp;&nbsp;</tt></TD>
<TD>&nbsp;(na)</TD>
</TR>
</Table>
</blockquote>

<p>
The first four bit operators listed in the table are based on the AND, OR,
XOR, and NOT operators for single bits, given by the following tables:
</p>

<ul>
<table border = 0>
<tr>
<td>
<Table border=4 cellspacing=0>
<TR>
<TD COLSPAN = 3>&nbsp; AND </TD>
</TR>
<TR>
<TD align = "center">&nbsp; <tt>x</tt> &nbsp; </TD>
<TD align = "center">&nbsp; <tt>y</tt> &nbsp; </TD>
<TD align = "center">&nbsp; <tt>x&amp;y</tt> &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
</TR>
</Table>
</td>
<td>
<Table border=4 cellspacing=0>
<TR>
<TD COLSPAN = 3>&nbsp; OR </TD>
</TR>
<TR>
<TD align = "center">&nbsp; <tt>x</tt> &nbsp; </TD>
<TD align = "center">&nbsp; <tt>y</tt> &nbsp; </TD>
<TD align = "center">&nbsp; <tt>x|y</tt> &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
</TR>
</Table>
</td>
<td>
<Table border=4 cellspacing=0>
<TR>
<TD COLSPAN = 3>&nbsp; XOR </TD>
</TR>
<TR>
<TD align = "center">&nbsp; <tt>x</tt> &nbsp; </TD>
<TD align = "center">&nbsp; <tt>y</tt> &nbsp; </TD>
<TD align = "center">&nbsp; <tt>x^y</tt> &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
</TR>
</Table>
</td>
<td valign = "top">
<Table border=4 cellspacing=0>
<TR>
<TD COLSPAN = 2>&nbsp; NOT </TD>
</TR>
<TR>
<TD align = "center">&nbsp; <tt>x</tt> &nbsp; </TD>
<TD align = "center">&nbsp; <tt>~x</tt> &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
</TR>
<TR>
<TD align = "center"> &nbsp; 1 &nbsp; </TD>
<TD align = "center"> &nbsp; 0 &nbsp; </TD>
</TR>
</Table>
</td>

</tr>
</table>
</ul>

<p>
Such tables are often called <em>truth tables</em>, a term from
symbolic logic for the table of truth values of a logical expression based on
truth/falsity of the variables in the expression. This is one of the areas where
logic, math, electrical engineering, and computer architecture intersect. The
table represents: (1) all possible values of a logical expression
(<em>logic</em>), (2) a table of values for a binary function (<em>math</em>),
(3) a table of electrical charge input/output for a circuit (<em>electrical
engineering</em>), and (4) a basic component of a digital computer (<em>computer
architecture</em>). In the modern computer, these bit-level operations have
one-clock-cycle hardware implementations.
</p>

<p>
The C/C++ bit operators <tt>&</tt>, <tt>|</tt>, <tt>^</tt>, and <tt>~</tt> are
defined for any integral type (such as <tt>char</tt>,
<tt>short</tt>, <tt>size_t</tt>, and <tt>long</tt>) by applying the
single-bit operations <em>bitwise</em>. In other words, these operators simply
apply the single-bit operations in parallel for each bit of the operand. The
parallel application of the single-bit operations is also supported by hardware,
so that the bitwise operators also operate in one clock cycle -- fast.
</p>
<p>
The other two bit operators shown are the left shift (<tt>operator
&lt;&lt; ()</tt>) and right shift (<tt>operator &gt;&gt; ()</tt>). These
two-argument operators take an integral type as the left operand and
a non-negative integer as the right operand, and return the same integral type
as the left operand. The prototypes for the shift of unsigned long, for example,
are: 
</p>

<pre><tt>  unsigned long operator &lt;&lt; (unsigned long , int);
  unsigned long operator &gt;&gt; (unsigned long , int);
</tt></pre>

<p>
The shift operators move the bits of the left argument the
number of times given by the right argument and return the (shifted) left argument
as a value. Bits that are shifted out of the left operand are lost (it is said
that these bits go into the "bit bucket") and bits uncovered by shifting are
replaced by bit <tt>0</tt>. Left and right shift also have hardware support, so
that they execute much more quickly than standard arithmetic operators.
</p>
<p>
<h2>Notes:</h2>

<ol>
<li>A point not to be confused over is the term "binary" as it is often applied to
operators. A <em>binary operator</em> is an operator that takes two
arguments. Similarly, a <em>unary operator</em> is an operator that takes only
one argument. In this usage, the term "binary" is referring to the number of arguments,
not their type.</li>
<li>Left shift <tt>&lt;&lt;()</tt> and right shift <tt>&gt;&gt;()</tt> are
native C/C++ operators. The C++ input and output operators are overloads of
these natives of C. </li>
<li>Shift operators are generally recommended only for unsigned integer
types. Some shift operator behaviors on signed type are machine dependent,
making their use unpredictable.</li>
<li>The shift operators are undefined when the right argument is negative or is
larger than the number of bits in the binary representation of the first argument.</li>
</ol>

</p><a NAME="Link3"></a><h1>Examples of Bit Operator Calculations</h1>
<p>

This table shows some examples of bit operations in action.
</p>

<ul>
<Table border=4 cellspacing=0>
<TR>
<TD>&nbsp;<em>value of x</em>&nbsp;</TD>
<TD>&nbsp;<em>value of y</em>&nbsp;</TD>
<TD>&nbsp;<em>statement</em>&nbsp;</TD>
<TD>&nbsp;<em>value of z</em>&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>00001000</tt<&nbsp;</TD>
<TD>&nbsp;<tt>2</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = x &lt;&lt; y</tt>&nbsp;</TD>
<TD>&nbsp;<tt>00100000</tt<&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>00001000</tt<&nbsp;</TD>
<TD>&nbsp;<tt>3</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = x &gt;&gt; y</tt>&nbsp;</TD>
<TD>&nbsp;<tt>00000001</tt<&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>10111001</tt<&nbsp;</TD>
<TD>&nbsp;<tt>00100000</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = x &amp; y</tt>&nbsp;</TD>
<TD>&nbsp;<tt>00100000</tt<&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>10011001</tt<&nbsp;</TD>
<TD>&nbsp;<tt>00100000</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = x &amp; y</tt>&nbsp;</TD>
<TD>&nbsp;<tt>00000000</tt<&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>10111001</tt<&nbsp;</TD>
<TD>&nbsp;<tt>11101111</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = x | y</tt>&nbsp;</TD>
<TD>&nbsp;<tt>11111111</tt<&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>10101001</tt<&nbsp;</TD>
<TD>&nbsp;<tt>11101111</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = x | y</tt>&nbsp;</TD>
<TD>&nbsp;<tt>11101111</tt<&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>10101001</tt<&nbsp;</TD>
<TD>&nbsp;<tt>00010000</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = x ^ y</tt>&nbsp;</TD>
<TD>&nbsp;<tt>10111001</tt<&nbsp;</TD>
</TR>
<TR>
<TD>&nbsp;<tt>11010010</tt<&nbsp;</TD>
<TD>&nbsp;<tt>(na)</tt<&nbsp;</TD>
<TD>&nbsp;<tt>z = ~x</tt>&nbsp;</TD>
<TD>&nbsp;<tt>00101101</tt<&nbsp;</TD>
</TR>
</Table>
</ul>

<p>
You should be able
to perform such calculations yourself. Some practice might be called for to
ensure this.

<br>
</p><a NAME="Link4"></a><h1>Defining Class BitVector</h1>
<p>

Our goal in the remainder of this chapter is the development of a bit vector
class, which we will call <tt>BitVector</tt>. Following the established pattern,
we need a <em>public interface</em> and an <em>implementation plan</em>.
</p>

<h2>BitVector Public Interface</h2>

<p> There are not that many things one can do to a bit: a bit can be
<em>set</em> (meaning give it the value <tt>1</tt>) or <em>unset</em> (meaning
give it the value <tt>0</tt>); and one can <em>flip</em> a bit, (meaning change
its value from <tt>0</tt> to <tt>1</tt> or from <tt>1</tt> to <tt>0</tt>). An
ability to <em>test</em> the value of a bit is necessary if access is to be
useful. The return value of a test needs to be an integer type, which we will
interpret as a bit value.  These four functions form the core of the user
interface for our BitVector class. 
</p>

</p><blockquote><pre><font color = #990000>namespace fsu
{</font>
class BitVector
{
  public:
    ...
    void Set   (size_t index);        // make index bit = 1
    void Unset (size_t index);        // make index bit = 0
    void Flip  (size_t index);        // change index bit 
    int  Test  (size_t index) const;  // return index bit value
    ...
}; // class BitVector
<font color = #990000>} // namespace fsu</font>
</pre></blockquote><p>

Note that we have placed the <tt>BitVector</tt> class in the <tt><font color=#990000>namespace fsu</font></tt>. 
</p>
<p>

The public interface should also include constructors, a destructor, assignment
operator, and a method <tt>Size()</tt> which is intended to return the number of
bits stored in a BitVector object. (Due to implementation details, the unsigned
integer <tt>Size()</tt> will always be a multiple of eight.)

A design decision (that could be reversed later, without harm to existing client
programs) is that class <tt>BitVector</tt> will not have a default constructor:
The size requirement (number of bits) of a BitVector object must be known in
advance and passed to the constructor as a parameter.

</p><blockquote><pre>class BitVector
{
  public:
    ...
    explicit BitVector  (size_t);     // construct a BitVector with specified size
             BitVector  (const BitVector&amp;); // copy constructor      
             ~BitVector ();           // destructor
    BitVector&amp; operator = (const BitVector&amp; a);  // assignment operator
    size_t Size   () const;           // return size of bitvector
    ...
};
</pre></blockquote><p>

We will also overload the <tt>Set()</tt>, <tt>Unset()</tt>, and <tt>Flip()</tt>
methods so that they apply to the entire <tt>BitVector</tt> object when invoked
without an index parameter:

</p><blockquote><pre>class BitVector
{
  public:
    ...
    void Set   ();         // make all bits = 1
    void Unset ();         // make all bits = 0
    void Flip  ();         // change all bits 
    ...
};
</pre></blockquote><p>

These components are collected into a summary at the end of this chapter.

<br>
</p><a NAME="Link5"></a><h1>BitVector Implementation Plan</h1>
<p>


The implementation plan for BitVector is clever, embodying many of the bit
manipulation tricks invented and used by C programmers over the years. Don't
feel inadequate if you didn't immediately conceive a good implementation
plan. But be certain you understand the plan, as well as the details of the
implementation itself. You will need to demonstrate and use this knowledge
several times in this course as well as in succeeding courses and your
professional life.

</p>

<p>
The basic storage facility for bits will be a vector of bytes. A vector of
<i>n</i> bytes contains 8<i>n</i> bits (hence the size of a BitVector object
is a multiple of 8). The challenge is to index and access at the bit level. The
math of this is fairly straightforward: to get to the index <i>k</i>
bit, we divide <i>k</i> by 8 to get the byte and then count up to the bit in
that byte corresponding to the remainder. Here is an example:
</p>

<p>
Suppose we have a array v of bytes and we want the 29th bit. There are 8 bits
in v[0], 8 bits in v[1], and so on. Indexing these bits (beginning with index
0), bits 0 through 7 are in byte v[0], bits 8 through 15 are in byte v[1], bits
16 through 23 are in v[2], and bits 24 through 31 are in v[3]. Therefore, bit 29
is bit 5 in v[3]. Note that 29/8 = 3 (the byte number) and 29%8 = 5 (the bit
number).
</p>

<p>
To get to the bit with index <i>k</i>, we first divide <i>k</i> by 8
(integer division) obtaining a quotient <i>q</i> and remainder
<i>r</i>. (That is, <i>k</i> = 8*<i>q</i> + <i>r</i>.) Then
bit[<i>k</i>] is the <i>r</i>th bit of the <i>q</i>th byte, i.e., bit
<i>r</i> of v[<i>q</i>]. We have now reduced
the challenge to two problems:
</p>
<ol>
<li>Find the byteArray_ index for bit index <i>k</i> (the quotient)</li>
<li>Access the bit for bit-index <i>k</i> (the remainder)</li>
</ol>
<p>
Problem 1 is essentially solved, just return the value <i>k</i>/8. To solve
problem 2 we must finally "byte the bullet" and do some subatomic programming
using the concept of <em>mask</em>.
</p>

<h2>The Mask</h2>

<p>
A mask for a pattern of bit locations in an integral type is a word of that type
whose binary representation has bit <tt>1</tt> in the specified locations and
bit <tt>0</tt> elsewhere. For our purposes here, we may as well assume the type
is <tt>char</tt>, so that a word consists of a single byte, or eight
bits. (Alternative approaches replace bytes with 32-bit words, and use masks for
<tt>unsigned long</tt>, a 32-bit word.) Assuming type <tt>char</tt>, there are
eight possible 1-bit masks, as follows:

</p><blockquote><pre>00000001 = 00000001 &lt;&lt; 0    // == 1   == 0x01
00000010 = 00000001 &lt;&lt; 1    // == 2   == 0x02
00000100 = 00000001 &lt;&lt; 2    // == 4   == 0x04
00001000 = 00000001 &lt;&lt; 3    // == 8   == 0x08
00010000 = 00000001 &lt;&lt; 4    // == 16  == 0x10
00100000 = 00000001 &lt;&lt; 5    // == 32  == 0x20
01000000 = 00000001 &lt;&lt; 6    // == 64  == 0x40
10000000 = 00000001 &lt;&lt; 7    // == 128 == 0x80
</pre></blockquote><p>

Notice that each of these can be obtained from 00000001<sub>(2)</sub> =
1<sub>(10)</sub> = 0x01<sub>(16)</sub> by applying the left shift operator, as indicated in the list
above. (The decimal and hexadecimal representations of the mask are also shown above.)
</p>
<p>
A mask can be used
to access an individual bit of a byte. Suppose, for example, that we want to
access the third bit from the right of byte <tt>x</tt>. Calculate the value
</p>
<pre>  y = 4 & x
    = 00000100 & x
</pre>

<p>
Note that <tt>y</tt> can have only two values:
</p>
<pre><tt>  00000100 = 4, or
  00000000 = 0.
</tt></pre>

<p>
The test <tt>(y != 0)</tt> and the third bit of <tt>x</tt> have essentially the
same value, true or false. In effect, the value of the third bit (bit index 2,
relative to the byte) of <tt>x</tt> is equal to the value returned by the
boolean expression <tt>(((1 &lt;&lt; 2) & x) != 0)</tt>. The mask <tt>(1
&lt;&lt; 2)</tt> allows us to access the bit value indirectly using a test. The
access is also very fast, because all of the operations have direct hardware
support.
</p>
<p>
We have now solved problem 2. To access bit index <tt>k</tt>, we
use <tt>Mask = 1 &lt;&lt; (index % 8)</tt> applied to the byte
<tt>byteArray_[ByteNumber (index)]</tt>. This completes the implementation plan for
BitVector. 
</p>
<p>
The following private section of the <t>BitVector</tt> class facilitates this
implementation plan:

</p><blockquote><pre>class BitVector
{
    ...
  private:
    // data
    unsigned char * byteArray_;
    size_t          byteArraySize_;

    // methods
    size_t        ByteNumber (size_t indx) const;
    unsigned char Mask       (size_t indx) const;
};
</pre></blockquote><p>

The two private methods <tt>ByteNumber()</tt> and <tt>Mask()</tt> capture the
two main ideas for locating a particular bit in the bit vector.

<br>
</p><a NAME="Link6"></a><h1>Implementing BitVector</h1>
<p>

Implementations of the <tt>BitVector</tt> member functions are not lengthy, and
for the most part are straightforward applications of the ideas expressed above
combined with appropriate use of the bit operators discussed earlier. Exceptions
are the two private methods, whose implementations use clever ideas for
optimizing the computations that make them a "bit" difficult to
comprehend. (This is one good reason for building the BitVector class, so that
these precious details can be committed to computer, rather than human, memory.)
</p>

<h2>Class Definition</h2>

<p>

Here for reference is the complete class definition:

</p><blockquote><pre>class BitVector
{
  public:
    explicit BitVector  (size_t);     // construct a BitVector with specified size
             BitVector  (const BitVector&amp;); // copy constructor      
             ~BitVector ();           // destructor

    BitVector&amp; operator = (const BitVector&amp; a);  // assignment operator

    size_t Size () const;             // return size of bitvector

    void Set   (size_t index);        // make index bit = 1
    void Set   ();                    // make all bits = 1
    void Unset (size_t index);        // make index bit = 0
    void Unset ();                    // make all bits = 0
    void Flip  (size_t index);        // flip index bit (change value of bit)
    void Flip  ();                    // flip all bits 
    int  Test  (size_t index) const;  // return index bit value
   
  private:
    // data
    unsigned char * byteArray_;
    size_t          byteArraySize_;

    // methods
    size_t               ByteNumber (size_t indx) const;
    static unsigned char Mask       (size_t indx) const;
};
</pre></blockquote>

<h2>BitVector::ByteNumber</h2>

<p>
The implementation of <tt>ByteNumber()</tt> is a good example of "clever". We
have already established that the private method <tt>ByteNumber(index)</tt>
should return <tt>index/8</tt>, but the code below seems to return something
different: <tt>index &gt;&gt; 3</tt>. This is actually an optimization that
executes faster while accomplishing the same result. The critical observation is
that 8 = 2<sup>3</sup>, and for powers of 2 the right shift operator achieves
the same result as integer division: each right shift has the same effect as
division by 2, so right shifting 3 is the same as division by 8. (The reader
should verify this using pencil and paper.)  But, because right shift has
hardware support, it is much faster than integer division, hence, the
optimization.

</p><blockquote><pre>size_t BitVector::ByteNumber (size_t index) const
{
  // return index / 8
  // shift right 3 is equivalent to, and faster than, dividing by 8
  index = index >> 3;
  if (index >= byteArraySize_)
  {
    std::cerr << "** BitVector error: index out of range\n";
    exit (EXIT_FAILURE);
  }
  return index;
}
</pre></blockquote>

<h2>BitVector::Mask</h2>

<p>
A similarly clever trick is used in to implement the <tt>Mask</tt>
method. This time, the observation is that the remainder when dividing a number by a
power k of 2 is equal to the last k bits of the number in binary
representation. (These are the bits that are lost to the bit bucket during the
right shift by k.) Thus, the remainder when dividing by 8 is just the last 3
bits of the number, which we can access by bitwise AND with a mask of 7 = 0x07 =
00000111<sub>2</sub>. Again, using the mask and the AND operator is much faster
than division because of the hardware support for the bit operators. Then, we
shift 00000001<sub>2</sub> = 0x01 = 1 by that amount to have the mask for
<tt>index</tt>.

</p><blockquote><pre>unsigned char BitVector::Mask (size_t index) const
{
  // return mask for index % 8
  // the low order 3 bits is the remainder when dividing by 8
  size_t shiftamount = index & 0x07;  // low order 3 bits
  return 0x01 << shiftamount;
}
</pre></blockquote><p>

<strong>Note:</strong>The <tt>Mask</tt> method is declared as <tt>static</tt>. The
connotation is that the method does not use any (non-static) class variables. It
is good software engineering practice to declare any method that does not need
access to object-level variables <tt>static</tt>. This results in improved compiler
optimizations and provides protection against inadvertant access to object data
in the implementation of the method.
</p>

<p>
Here is a picture of the bitvector, layed out with the byteVector elements right
to left so that the order of the bits increases from right to left (like a
number): 

</p><blockquote><pre>
i = ... 76543210 98765432 10987654 32109876 54321098 76543210
b = ... 5        4        3        2        1        0        
v = ... ******** ******** ******** ******** ******** ********

 where i = bit index   (showing only the first digit of i)
       b = byte number (aka byteVector index)
       v = byteArray   (spaces just for readability)
</pre></blockquote><p>

So for example if <tt>i</tt> = 19 then

</p><blockquote><pre> i = 19
 b = 19/8 = 2 and
 m = (0x01 << 19%8) = (0x01 << 3) = 00001000,
</pre></blockquote><p>

and the specific picture is:

</p><blockquote><pre>
b = ... 5        4        3        2        1        0        
v = ... ******** ******** ******** ****x*** ******** ********
i = ...                                1            
m =                                00001000                  
</pre></blockquote><p>

In words: bit 19 is in the array element 2 and has mask <tt>00001000</tt>.  Note
that <tt>mask & v[2] = 0000x000</tt>: the byte <tt>0000x000</tt> is zero
iff the bit <tt>x</tt> is zero, which is the way Test(i) is implemented:

</p><blockquote><pre> Test(11) = 1 if x = one and
 Test(11) = 0 if x = zero
</pre></blockquote><p>

Thus we have a way of detecting the value of bit
<tt>11</tt> without having direct access to it.


<h2>BitVector Constructor</h2>

<p>
The constructor takes a size parameter and calls operator <tt>new unsigned char</tt> with
parameter equal to the integer that is just larger or equal to
<tt>numbits/8</tt>.

</p><blockquote><pre>BitVector::BitVector (size_t numbits)  // constructor
{
  byteArraySize_ = (numbits + 7)/8;
  byteArray_ = new unsigned char [byteArraySize_];
  if (byteArray_ == 0)
  {
    std::cerr << "** BitVector memory allocation failure -- terminating program.\n";
    exit (EXIT_FAILURE);
  }
  for (size_t i = 0; i < byteArraySize_; ++i)
    byteArray_[i] = 0x00;
}
</pre></blockquote>

<h2>BitVector Assignment Operator</h2>

<p>

The assignment operator follows the typical pattern:

</p><blockquote><pre>BitVector& BitVector::operator = (const BitVector& bv)  //
assignment operator
{
  if (this != &bv)
  {
    if (byteArraySize_ != bv.byteArraySize_)
    {
      delete [] byteArray_;
      byteArraySize_ = bv.byteArraySize_;
      byteArray_ = new unsigned char [byteArraySize_];
      if (byteArray_ == 0)
      {
        std::cerr << "** BitVector memory allocation failure -- terminating program.\n";
        exit (EXIT_FAILURE);
      }
    }
    for (size_t i = 0; i < byteArraySize_; ++i)
      byteArray_[i] = bv.byteArray_[i];
  }
  return *this;
}
</pre></blockquote>

<h2>BitVector API</h2>

<p>
The BitVector API consists of the public methods <tt>Set</tt>, <tt>Unset</tt>,
<tt>Flip</tt>, and <tt>Test</tt> (two versions of each of the first three). 
</p>

<p>
The <tt>Test(index)</tt> method, like the remaining methods taking an index
parameter, is a one-liner. But the line is...clever. The idea is to isolate the
indexed bit with a mask and test for non-zero result, as we established
earlier. Look carefully at the computation shown and be certain you understand
it.

</p><blockquote><pre>int BitVector::Test  (size_t index) const  
// return specified bit value
{
   return 0 != (byteArray_[ByteNumber(index)] & Mask(index));
}
</pre></blockquote><p>

Our final example is the <tt>Set(index)</tt> method, another one-liner:

</p><blockquote><pre>void BitVector::Set (size_t index)
// set specified bit
{ 
  byteArray_[ByteNumber(index)] |= Mask(index);                                                
}
</pre></blockquote><p>


The rest of the implementation of BitVector is left as an
assignment. Enjoy.
</p>

<br>
</p><a NAME="Link7"></a><h1>Sample BitVector Client</h1>
<p>
Appended below is source code for a straightforward functionality test client for
BitVector. Here are some key attributes of the program:
</p>
<ul>
<li>The program allows the user to set the bitvector size at the beginning of
the test.</li>
<li>To allow the user to set the bitvector size, dynamic allocation
must be used (operators <tt>new</tt> and <tt>delete</tt>).</li>
<li>The user is presented a simple interface that gives access to most of the
public interface of BitVector.</li>
<li>Assignment and copy constructor are not tested by this program.</li>
</ul>
<p>
The test client can also be used as a device to discover by experiment how
bitvectors behave. An executable of this client may be
accessed in <tt>area51</tt>. If you want to get the feel
of bitvector use, give this a try. Copy the executable into your
directory and run it by typing the name.

</p><blockquote><pre>/*  fbitvect.cpp

    testing BitVector
*/

#include &lt;xbitvect.cpp&gt;

void display_menu(unsigned int size);

int main()
{
  char selection;
  size_t size, index;
  std::cout &lt;&lt; "Welcome to fbitvect. Enter size of BitVector: ";
  std::cin &gt;&gt; size;
  <font color = #990000>fsu::BitVector * bvptr = new fsu::BitVector (size);</font>
  display_menu(size);
  do
  {
    std::cout &lt;&lt; "  Enter [op][index] (m for menu, x to exit): ";
    std::cin &gt;&gt; selection;
    switch(selection)
    {
      case 'S':
        <font color = #990000>bvptr-&gt;Set();</font>
        break;
      case 'U':
        bvptr-&gt;Unset();
        break;
      case 'F':
        bvptr-&gt;Flip();
        break;
      case 's':
        std::cin &gt;&gt; index;
        bvptr-&gt;Set(index);
        break;
      case 'u':
        std::cin &gt;&gt; index;
        bvptr-&gt;Unset(index);
        break;
      case 'f':
        std::cin &gt;&gt; index;
        bvptr-&gt;Flip(index);
        break;
      case 't': case 'T':
        std::cin &gt;&gt; index;
        std::cout &lt;&lt; "  v[" &lt;&lt; index &lt;&lt; "] == ";
        if (bvptr-&gt;Test(index))
          std::cout &lt;&lt; "1\n";
        else
          std::cout &lt;&lt; "0\n";
        break;
      case 'd': case 'D':
        std::cout &lt;&lt; "  v == " &lt;&lt; *bvptr &lt;&lt; '\n';
        break;
      case 'm': case 'M':
        display_menu(size);
        break;
      case 'x': case 'X':
        break;
      default:
        std::cout &lt;&lt; "  command not found\n";
    }
  }
  while (selection != 'x' &amp;&amp; selection != 'X');
  <font color = #990000>delete bvptr;</font>
  std::cout &lt;&lt; "Thank you for testing BitVector\n";
  return 0;
}

void display_menu(unsigned int size)
{
   std::cout &lt;&lt; "     BitVector (" &lt;&lt; size &lt;&lt; ") v;\n"   
             &lt;&lt; "     operation                                entry\n"
             &lt;&lt; "     ---------                                -----\n"
             &lt;&lt; "     v.Set            ()  ......................  S\n"
             &lt;&lt; "     v.Set            (index)  .................  s\n"
             &lt;&lt; "     v.Unset          ()  ......................  U\n"
             &lt;&lt; "     v.Unset          (index)  .................  u\n"
             &lt;&lt; "     v.Flip           ()  ......................  F\n"
             &lt;&lt; "     v.Flip           (index)  .................  f\n"
             &lt;&lt; "     v.Test           (index)  .................  t\n"
             &lt;&lt; "     cout << v  ................................  d\n"
             &lt;&lt; "     display this Menu  ........................  m\n"
             &lt;&lt; "     eXit program  .............................  x\n";
}
</PRE>

</BODY>
</HTML>
</pre></blockquote><p>

This harness does not test the copy constructor and assignment operator. To
expand the program to include test of the assignment operator would require
defining three bitvector objects (instead of one as above) and adding for each
of these objects all of the options above plus assignment plus three-way
assignment. A function call (passing a bitvector by value) and return would be a
good test of the copy constructor.
</p>
</body>
</html>